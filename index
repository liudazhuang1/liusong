<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>圣诞树 · Merry Christmas</title>
  <style>
    :root{
      --bg1:#081428;
      --bg2:#0b2a3d;
      --glow:#9bf1ff;
      --gold:#ffd36a;
      --tree1:#0d3b2a;
      --tree2:#0a6b45;
      --snow:rgba(255,255,255,.9);
    }
    html,body{height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Microsoft YaHei, Arial;}
    body{
      overflow:hidden;
      background: radial-gradient(1200px 900px at 60% 20%, #163a63 0%, var(--bg2) 35%, var(--bg1) 75%, #030813 100%);
      color:#fff;
    }

    /* subtle stars */
    .stars::before{
      content:"";
      position:fixed; inset:-20%;
      background:
        radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,.7) 90%, transparent 100%),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,.6) 90%, transparent 100%),
        radial-gradient(1px 1px at 70% 30%, rgba(255,255,255,.65) 90%, transparent 100%),
        radial-gradient(1px 1px at 85% 70%, rgba(255,255,255,.55) 90%, transparent 100%),
        radial-gradient(1px 1px at 50% 55%, rgba(255,255,255,.6) 90%, transparent 100%),
        radial-gradient(1px 1px at 15% 60%, rgba(255,255,255,.5) 90%, transparent 100%),
        radial-gradient(1px 1px at 90% 15%, rgba(255,255,255,.55) 90%, transparent 100%);
      opacity:.55;
      filter: drop-shadow(0 0 6px rgba(155,241,255,.25));
      pointer-events:none;
      transform: rotate(-8deg);
    }

    canvas{position:fixed; inset:0; width:100%; height:100%; display:block;}
    .ui{
      position:fixed;
      left:16px; top:16px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      z-index:10;
      user-select:none;
    }
    .chip{
      backdrop-filter: blur(10px);
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      border-radius: 999px;
      padding: 10px 12px;
      display:flex; gap:10px; align-items:center;
    }
    button{
      appearance:none; border:0; color:#06121f;
      padding:10px 14px; border-radius:999px;
      background: linear-gradient(180deg, #bff7ff 0%, #7be8ff 60%, #52cfff 100%);
      cursor:pointer; font-weight:700;
      box-shadow: 0 12px 26px rgba(0,0,0,.35), 0 0 18px rgba(155,241,255,.18);
    }
    button:active{transform: translateY(1px);}
    .label{
      color: rgba(255,255,255,.85);
      font-size: 13px;
      letter-spacing:.2px;
    }
    .title{
      position:fixed; right:18px; top:16px;
      z-index:10;
      text-align:right;
      text-shadow: 0 10px 40px rgba(0,0,0,.55);
    }
    .title h1{margin:0; font-size:20px; font-weight:800; letter-spacing:.5px;}
    .title p{margin:6px 0 0; font-size:13px; color:rgba(255,255,255,.75);}
    .hint{
      position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
      z-index:10;
      color: rgba(255,255,255,.75);
      font-size: 13px;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      user-select:none;
      max-width: calc(100% - 24px);
      text-align:center;
    }
    a{color:#aeefff}
  </style>
</head>
<body>
  <div class="stars"></div>
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="chip">
      <button id="musicBtn">播放音乐</button>
      <span class="label" id="musicState">点击后开始（浏览器限制自动播放）</span>
    </div>
    <div class="chip">
      <span class="label">彩灯：<b id="lightsState">闪烁</b>｜雪花：<b id="snowState">开启</b></span>
      <button id="toggleLights">切换彩灯</button>
      <button id="toggleSnow">切换雪花</button>
    </div>
  </div>

  <div class="title">
    <h1>圣诞快乐 · Merry Christmas</h1>
    <p>点击树上的彩灯也会“更亮”一点</p>
  </div>

  <div class="hint">提示：若没声音，请先点击左上角“播放音乐”。用鼠标/手指点击树区域可触发小小光晕。</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W, H, DPR;

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = canvas.width = Math.floor(innerWidth * DPR);
    H = canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  const state = {
    t: 0,
    lightsOn: true,
    snowOn: true,
    touchGlow: 0,
    touchX: 0.5,
    touchY: 0.55
  };

  // --- Snow particles ---
  const snow = [];
  function spawnSnow(n=180){
    snow.length = 0;
    for(let i=0;i<n;i++){
      snow.push({
        x: Math.random()*W,
        y: Math.random()*H,
        r: (Math.random()*1.6 + 0.6) * DPR,
        v: (Math.random()*0.9 + 0.25) * DPR,
        sway: (Math.random()*0.9 + 0.2) * DPR,
        a: Math.random()*Math.PI*2
      });
    }
  }
  spawnSnow();

  // --- Tree geometry ---
  function drawBackground(){
    // soft aurora glow
    const g = ctx.createRadialGradient(W*0.55, H*0.25, 10, W*0.55, H*0.25, Math.max(W,H)*0.7);
    g.addColorStop(0, "rgba(155,241,255,0.14)");
    g.addColorStop(0.35, "rgba(78,210,255,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // ground
    const ground = ctx.createLinearGradient(0,H*0.72,0,H);
    ground.addColorStop(0,"rgba(255,255,255,0)");
    ground.addColorStop(0.25,"rgba(255,255,255,0.10)");
    ground.addColorStop(1,"rgba(255,255,255,0.22)");
    ctx.fillStyle = ground;
    ctx.fillRect(0,H*0.7,W,H*0.3);
  }

  function drawTree(){
    const cx = W*0.5, baseY = H*0.80;
    const height = Math.min(H*0.62, W*0.78);
    const topY = baseY - height;
    const wMax = Math.min(W*0.42, height*0.62);

    // trunk
    const trunkW = wMax*0.16;
    const trunkH = height*0.16;
    const trunkGrad = ctx.createLinearGradient(cx-trunkW, baseY-trunkH, cx+trunkW, baseY);
    trunkGrad.addColorStop(0, "#3a2412");
    trunkGrad.addColorStop(0.5, "#5a371c");
    trunkGrad.addColorStop(1, "#2a180c");
    ctx.fillStyle = trunkGrad;
    roundRect(cx-trunkW*0.55, baseY-trunkH*0.55, trunkW*1.1, trunkH*0.62, 10*DPR);
    ctx.fill();

    // tree layers (stylized)
    const layers = 6;
    for(let i=0;i<layers;i++){
      const p = i/(layers-1);
      const y = lerp(topY+height*0.10, baseY-height*0.05, p);
      const w = lerp(wMax*0.32, wMax, p);
      const h = lerp(height*0.13, height*0.18, p);
      const grad = ctx.createLinearGradient(cx-w, y-h, cx+w, y+h);
      grad.addColorStop(0, "rgba(10,107,69,0.95)");
      grad.addColorStop(0.5, "rgba(13,59,42,0.98)");
      grad.addColorStop(1, "rgba(8,42,30,0.96)");
      ctx.fillStyle = grad;

      ctx.beginPath();
      ctx.moveTo(cx, y-h);
      ctx.bezierCurveTo(cx-w*0.85, y-h*0.25, cx-w, y+h*0.35, cx, y+h);
      ctx.bezierCurveTo(cx+w, y+h*0.35, cx+w*0.85, y-h*0.25, cx, y-h);
      ctx.closePath();
      ctx.fill();

      // snow cap highlight
      const snowCap = ctx.createRadialGradient(cx-w*0.2, y-h*0.55, 1, cx, y-h*0.2, w*0.85);
      snowCap.addColorStop(0, "rgba(255,255,255,0.30)");
      snowCap.addColorStop(0.6, "rgba(255,255,255,0.06)");
      snowCap.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = snowCap;
      ctx.fill();
    }

    // garland string
    ctx.lineWidth = 2.2*DPR;
    ctx.strokeStyle = "rgba(255,215,140,0.42)";
    ctx.shadowColor = "rgba(255,211,106,0.18)";
    ctx.shadowBlur = 12*DPR;
    ctx.beginPath();
    for(let i=0;i<80;i++){
      const p = i/79;
      const y = lerp(topY+height*0.16, baseY-height*0.12, p);
      const amp = lerp(wMax*0.08, wMax*0.42, p);
      const x = cx + Math.sin(p*9.2 + state.t*0.7)*amp;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    // ornaments + lights
    const ornaments = [];
    const lightCount = 46;
    for(let i=0;i<lightCount;i++){
      const p = (i+1)/(lightCount+1);
      const y = lerp(topY+height*0.18, baseY-height*0.16, p);
      const halfW = lerp(wMax*0.18, wMax*0.52, p);
      const x = cx + (Math.sin(p*13.0 + i*1.7)*0.55 + (Math.random()*0.1-0.05))*halfW;
      ornaments.push({x,y, p, type: i%3});
    }

    // touch glow hotspot
    if(state.touchGlow > 0.001){
      const gx = state.touchX*W, gy = state.touchY*H;
      const rg = ctx.createRadialGradient(gx,gy, 0, gx,gy, 160*DPR);
      rg.addColorStop(0, `rgba(155,241,255,${0.22*state.touchGlow})`);
      rg.addColorStop(0.4, `rgba(155,241,255,${0.10*state.touchGlow})`);
      rg.addColorStop(1, "rgba(155,241,255,0)");
      ctx.fillStyle = rg;
      ctx.fillRect(gx-200*DPR, gy-200*DPR, 400*DPR, 400*DPR);
    }

    // draw bulbs
    for(let i=0;i<ornaments.length;i++){
      const o = ornaments[i];
      const tw = 0.5 + 0.5*Math.sin(state.t*3 + o.p*12 + i);
      const on = state.lightsOn ? 1 : 0;
      const pulse = (0.25 + 0.75*tw) * on + (0.18)*(1-on);

      const colors = [
        [255, 90, 120],   // pink-red
        [120, 255, 190],  // mint
        [110, 190, 255],  // blue
      ][o.type];

      const r = (4.2 + 2.6*tw) * DPR;
      // outer glow
      ctx.beginPath();
      ctx.fillStyle = `rgba(${colors[0]},${colors[1]},${colors[2]},${0.12 + 0.22*pulse})`;
      ctx.arc(o.x,o.y, r*3.0, 0, Math.PI*2);
      ctx.fill();

      // bulb body
      const grad = ctx.createRadialGradient(o.x-r*0.5,o.y-r*0.5, 1, o.x,o.y, r*1.6);
      grad.addColorStop(0, `rgba(255,255,255,${0.85*pulse})`);
      grad.addColorStop(0.2, `rgba(${colors[0]},${colors[1]},${colors[2]},${0.95*pulse})`);
      grad.addColorStop(1, `rgba(${Math.floor(colors[0]*0.55)},${Math.floor(colors[1]*0.55)},${Math.floor(colors[2]*0.55)},${0.90*pulse})`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(o.x,o.y, r, 0, Math.PI*2);
      ctx.fill();

      // tiny highlight
      ctx.fillStyle = `rgba(255,255,255,${0.35*pulse})`;
      ctx.beginPath();
      ctx.arc(o.x-r*0.35,o.y-r*0.35, r*0.35, 0, Math.PI*2);
      ctx.fill();
    }

    // top star
    const starX = cx, starY = topY + height*0.06;
    const starR = 18*DPR;
    const starPulse = 0.55 + 0.45*Math.sin(state.t*2.2);
    ctx.save();
    ctx.translate(starX, starY);
    ctx.rotate(Math.sin(state.t*0.6)*0.06);
    // glow
    const sg = ctx.createRadialGradient(0,0, 1, 0,0, 120*DPR);
    sg.addColorStop(0, `rgba(255,211,106,${0.55*starPulse})`);
    sg.addColorStop(0.25, `rgba(255,211,106,${0.22*starPulse})`);
    sg.addColorStop(1, "rgba(255,211,106,0)");
    ctx.fillStyle = sg;
    ctx.beginPath(); ctx.arc(0,0, 120*DPR, 0, Math.PI*2); ctx.fill();

    // star body
    ctx.fillStyle = `rgba(255,211,106,${0.95})`;
    ctx.strokeStyle = `rgba(255,255,255,${0.35})`;
    ctx.lineWidth = 1.2*DPR;
    drawStar(0,0, starR, starR*0.45, 5);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // gifts
    const gy = baseY + height*0.02;
    drawGift(cx-wMax*0.40, gy, 66*DPR, 46*DPR, "#ff4d6d", "#ffd36a");
    drawGift(cx-wMax*0.18, gy+12*DPR, 56*DPR, 40*DPR, "#4dd6ff", "#ffffff");
    drawGift(cx+wMax*0.22, gy+6*DPR, 72*DPR, 50*DPR, "#6dff9e", "#ff4d6d");

    // tree shadow
    const sh = ctx.createRadialGradient(cx, baseY+20*DPR, 10, cx, baseY+20*DPR, wMax*0.9);
    sh.addColorStop(0, "rgba(0,0,0,0.35)");
    sh.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = sh;
    ctx.beginPath();
    ctx.ellipse(cx, baseY+22*DPR, wMax*0.65, height*0.08, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function drawGift(x, y, w, h, c1, ribbon){
    // box
    const g = ctx.createLinearGradient(x, y-h, x+w, y);
    g.addColorStop(0, shade(c1, 0.12));
    g.addColorStop(0.5, c1);
    g.addColorStop(1, shade(c1, -0.18));
    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 1*DPR;
    roundRect(x, y-h, w, h, 10*DPR);
    ctx.fill(); ctx.stroke();

    // ribbon vertical
    ctx.fillStyle = ribbon;
    roundRect(x+w*0.44, y-h, w*0.12, h, 6*DPR);
    ctx.fill();
    // ribbon horizontal
    roundRect(x, y-h*0.58, w, h*0.12, 6*DPR);
    ctx.fill();

    // bow
    ctx.save();
    ctx.translate(x+w*0.5, y-h*0.62);
    ctx.fillStyle = shade(ribbon, -0.05);
    ctx.beginPath();
    ctx.ellipse(-w*0.09, -h*0.10, w*0.10, h*0.12, -0.4, 0, Math.PI*2);
    ctx.ellipse(w*0.09, -h*0.10, w*0.10, h*0.12, 0.4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.beginPath(); ctx.arc(0,-h*0.07, Math.min(w,h)*0.06, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawSnow(){
    if(!state.snowOn) return;
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.shadowColor = "rgba(155,241,255,0.20)";
    ctx.shadowBlur = 12*DPR;

    for(const s of snow){
      s.a += 0.01;
      s.y += s.v;
      s.x += Math.sin(s.a)*s.sway*0.18;

      if(s.y > H + 10*DPR){
        s.y = -10*DPR;
        s.x = Math.random()*W;
      }
      if(s.x < -20*DPR) s.x = W + 20*DPR;
      if(s.x > W + 20*DPR) s.x = -20*DPR;

      ctx.globalAlpha = 0.5 + 0.5*Math.random();
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function animate(ts){
    state.t = ts/1000;

    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawTree();
    drawSnow();

    // decay touch glow
    state.touchGlow *= 0.92;
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);

  // click/tap glow
  function pointer(e){
    const rect = canvas.getBoundingClientRect();
    const x = ('touches' in e) ? e.touches[0].clientX : e.clientX;
    const y = ('touches' in e) ? e.touches[0].clientY : e.clientY;
    state.touchX = (x - rect.left)/rect.width;
    state.touchY = (y - rect.top)/rect.height;
    state.touchGlow = 1;
  }
  canvas.addEventListener('pointerdown', pointer, {passive:true});
  canvas.addEventListener('touchstart', pointer, {passive:true});

  // --- UI toggles ---
  const lightsState = document.getElementById('lightsState');
  const snowState = document.getElementById('snowState');
  document.getElementById('toggleLights').onclick = () => {
    state.lightsOn = !state.lightsOn;
    lightsState.textContent = state.lightsOn ? "闪烁" : "常暗";
  };
  document.getElementById('toggleSnow').onclick = () => {
    state.snowOn = !state.snowOn;
    snowState.textContent = state.snowOn ? "开启" : "关闭";
  };

  // --- Music (WebAudio, offline) ---
  const musicBtn = document.getElementById('musicBtn');
  const musicState = document.getElementById('musicState');

  let audioCtx = null;
  let master = null;
  let playing = false;
  let stopFlag = false;

  const NOTES = {
    C4:261.63, Cs4:277.18, D4:293.66, Ds4:311.13, E4:329.63, F4:349.23, Fs4:369.99, G4:392.00, Gs4:415.30, A4:440.00, As4:466.16, B4:493.88,
    C5:523.25, D5:587.33, E5:659.25, F5:698.46, G5:783.99, A5:880.00
  };

  // Simple "Jingle Bells" motif (approx) + loop
  const melody = [
    ["E5",0.25],["E5",0.25],["E5",0.5],
    ["E5",0.25],["E5",0.25],["E5",0.5],
    ["E5",0.25],["G5",0.25],["C5",0.25],["D5",0.25],["E5",0.75],

    ["F5",0.25],["F5",0.25],["F5",0.25],["F5",0.25],
    ["F5",0.25],["E5",0.25],["E5",0.25],["E5",0.125],["E5",0.125],
    ["E5",0.25],["D5",0.25],["D5",0.25],["E5",0.25],["D5",0.5],["G5",0.5],
  ];

  const bass = [
    ["C4",0.5],["G4",0.5],["C4",0.5],["G4",0.5],
    ["F4",0.5],["C4",0.5],["G4",0.5],["C4",0.5],
  ];

  function ensureAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain();
    master.gain.value = 0.55;
    master.connect(audioCtx.destination);
  }

  function tone(freq, start, dur, type="sine", gain=0.18){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = type;
    o.frequency.setValueAtTime(freq, start);

    // envelope
    g.gain.setValueAtTime(0.0001, start);
    g.gain.exponentialRampToValueAtTime(gain, start + 0.015);
    g.gain.exponentialRampToValueAtTime(0.0001, start + dur);

    o.connect(g);
    g.connect(master);

    o.start(start);
    o.stop(start + dur + 0.02);
  }

  async function playLoop(){
    ensureAudio();
    stopFlag = false;

    const tempo = 108; // bpm-ish
    const beat = 60/tempo;

    while(!stopFlag){
      const now = audioCtx.currentTime + 0.06;

      // a soft bell-ish pad
      const pad = audioCtx.createOscillator();
      const padG = audioCtx.createGain();
      pad.type = "triangle";
      pad.frequency.setValueAtTime(NOTES.C4, now);
      padG.gain.setValueAtTime(0.0001, now);
      padG.gain.exponentialRampToValueAtTime(0.06, now+0.05);
      padG.gain.exponentialRampToValueAtTime(0.0001, now+melody.reduce((a,b)=>a+b[1],0)*beat);
      pad.connect(padG); padG.connect(master);
      pad.start(now);
      pad.stop(now + melody.reduce((a,b)=>a+b[1],0)*beat + 0.05);

      // schedule melody
      let t = now;
      for(const [n, len] of melody){
        const f = NOTES[n];
        tone(f, t, len*beat*0.98, "sine", 0.16);
        // a tiny sparkle overtone
        tone(f*2, t+0.01, len*beat*0.55, "sine", 0.03);
        t += len*beat;
      }

      // schedule bass (repeat to match length)
      const melLen = melody.reduce((a,b)=>a+b[1],0)*beat;
      let tb = now;
      while(tb < now + melLen - 0.01){
        for(const [n,len] of bass){
          if(tb >= now + melLen - 0.01) break;
          tone(NOTES[n], tb, len*beat*0.98, "triangle", 0.10);
          tb += len*beat;
        }
      }

      // wait until loop end
      const waitMs = melLen*1000;
      await new Promise(r => setTimeout(r, waitMs));
    }
  }

  musicBtn.onclick = async () => {
    ensureAudio();
    if(audioCtx.state === "suspended") await audioCtx.resume();

    playing = !playing;
    if(playing){
      musicBtn.textContent = "暂停音乐";
      musicState.textContent = "正在播放（循环）";
      playLoop();
    }else{
      musicBtn.textContent = "播放音乐";
      musicState.textContent = "已暂停";
      stopFlag = true;
      // quick fade out
      if(master){
        const t = audioCtx.currentTime;
        master.gain.cancelScheduledValues(t);
        master.gain.setValueAtTime(master.gain.value, t);
        master.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
        setTimeout(()=>{ if(master) master.gain.value = 0.55; }, 160);
      }
    }
  };

  // --- helpers ---
  function lerp(a,b,t){ return a+(b-a)*t; }

  function roundRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
  function drawStar(x,y,outer,inner,points){
    let rot = Math.PI/2*3;
    let step = Math.PI/points;
    ctx.beginPath();
    ctx.moveTo(x, y-outer);
    for(let i=0;i<points;i++){
      ctx.lineTo(x+Math.cos(rot)*outer, y+Math.sin(rot)*outer);
      rot += step;
      ctx.lineTo(x+Math.cos(rot)*inner, y+Math.sin(rot)*inner);
      rot += step;
    }
    ctx.lineTo(x, y-outer);
    ctx.closePath();
  }
  function shade(hex, amt){
    // hex like #rrggbb
    const c = hex.replace('#','');
    const n = parseInt(c,16);
    let r = (n>>16)&255, g=(n>>8)&255, b=n&255;
    r = Math.max(0, Math.min(255, Math.round(r*(1+amt))));
    g = Math.max(0, Math.min(255, Math.round(g*(1+amt))));
    b = Math.max(0, Math.min(255, Math.round(b*(1+amt))));
    return `rgb(${r},${g},${b})`;
  }
})();
</script>
</body>
</html>
